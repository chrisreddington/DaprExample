package handlers

import (
	"net/http"
	"net/http/httptest"
	"testing"

	"github.com/cloudwithchris/event-platform/api/redirect/internal/core/domain"
	"github.com/cloudwithchris/event-platform/api/redirect/internal/core/services/redirectservice"
	"github.com/cloudwithchris/event-platform/api/redirect/internal/mocks/ports"
	"github.com/golang/mock/gomock"
	"github.com/gorilla/mux"
)

type subreporter struct {
	t []gomock.TestReporter
}

func newSubreporter(t gomock.TestReporter) *subreporter {
	return &subreporter{
		t: []gomock.TestReporter{t},
	}
}

func (r *subreporter) add(t gomock.TestReporter) func() {
	r.t = append(r.t, t)
	return func() {
		r.t = r.t[:len(r.t)-1]
	}
}

func (r *subreporter) Errorf(format string, args ...interface{}) {
	r.t[len(r.t)-1].Errorf(format, args...)
}
func (r *subreporter) Fatalf(format string, args ...interface{}) {
	r.t[len(r.t)-1].Fatalf(format, args...)
}

func Test_Get(t *testing.T) {
	// ARRANGE
	// Consistent setup across all tests
	// relating to the get handler
	subreporter := newSubreporter(t)

	// Generate the mock controller
	controller := gomock.NewController(subreporter)

	// Use the repository generated by the gomock package
	// This is generated either locally, or in the CI/CD pipeline
	// and is not stored in source control.
	mockRepository := ports.NewMockRedirectRepository(controller)

	// Create the service based on the mocked repository
	// Stub the mock service into the bookController
	mockService := redirectservice.NewService(mockRepository)
	redirectHandler := HttpHandler{mockService}

	// Create the routes
	router := mux.NewRouter()
	router.HandleFunc("/redirect", redirectHandler.Get).Methods("GET")
	router.HandleFunc("/redirect/{shortUrl}", redirectHandler.Get).Methods("GET")

	// Subtest 1: Get a redirect with a valid shortUrl
	t.Run("Existing_ShortUrl", func(t *testing.T) {

		// ARRANGE
		expectedRedirectResponseObject := domain.RedirectResponseObject{
			ShortUrl:       "blog",
			DestinationUrl: "https://blog.cloudwithchris.com",
			Campaign:       "test",
			Medium:         "test",
			Visits:         0,
		}
		defer subreporter.add(t)()

		// ACT
		// Fire a request to the route
		mockRepository.EXPECT().Read(gomock.Any()).Return(&expectedRedirectResponseObject, nil)
		request, _ := http.NewRequest(http.MethodGet, "/redirect/blog", nil)

		// Record the test response by using the
		// httptest.NewRecorder() function which
		// returns a ResponseRecorder
		recorder := httptest.NewRecorder()

		// Serve the request
		router.ServeHTTP(recorder, request)

		// ASSERT
		if recorder.Code != http.StatusFound {
			t.Error("Fail on testing status code")
		}

		if (recorder.Header().Get("Location")) != expectedRedirectResponseObject.DestinationUrl {
			t.Error("Fail on testing location header")
		}
	})

	// Subtest 2: Get a redirect with an invalid shortUrl
	t.Run("NonExistant_ShortUrl", func(t *testing.T) {

		// ARRANGE
		expectedRedirectResponseObject := domain.RedirectResponseObject{
			ShortUrl:       "blog",
			DestinationUrl: "https://www.cloudwithchris.com",
			Campaign:       "test",
			Medium:         "test",
			Visits:         0,
		}
		defer subreporter.add(t)()

		// ACT
		// Fire a request to the route
		mockRepository.EXPECT().Read(gomock.Any()).Return(&expectedRedirectResponseObject, nil)
		request, _ := http.NewRequest(http.MethodGet, "/redirect/doesnotexist", nil)

		// Record the test response by using the
		// httptest.NewRecorder() function which
		// returns a ResponseRecorder
		recorder := httptest.NewRecorder()

		// Serve the request
		router.ServeHTTP(recorder, request)

		// ASSERT

		if recorder.Code != http.StatusFound {
			t.Error("Fail on testing status code")
		}

		if (recorder.Header().Get("Location")) != expectedRedirectResponseObject.DestinationUrl {
			t.Error("Fail on testing location header")
		}
	})

	// Subtest 3: Get a redirect with no shortUrl
	t.Run("NoShortUrl", func(t *testing.T) {

		// ARRANGE
		expectedRedirectResponseObject := domain.RedirectResponseObject{
			ShortUrl:       "blog",
			DestinationUrl: "https://www.cloudwithchris.com",
			Campaign:       "test",
			Medium:         "test",
			Visits:         0,
		}
		defer subreporter.add(t)()

		// ACT
		// Fire a request to the route
		request, _ := http.NewRequest(http.MethodGet, "/redirect", nil)

		// Record the test response by using the
		// httptest.NewRecorder() function which
		// returns a ResponseRecorder
		recorder := httptest.NewRecorder()

		// Serve the request
		router.ServeHTTP(recorder, request)

		// ASSERT
		if recorder.Code != http.StatusFound {
			t.Error("Fail on testing status code")
		}

		if (recorder.Header().Get("Location")) != expectedRedirectResponseObject.DestinationUrl {
			t.Error("Fail on testing status code")
		}
	})
}

func Test_Create(t *testing.T) {
	// ARRANGE
	// Consistent setup across all tests
	// relating to the get handler
	subreporter := newSubreporter(t)

	// Generate the mock controller
	controller := gomock.NewController(subreporter)

	// Use the repository generated by the gomock package
	// This is generated either locally, or in the CI/CD pipeline
	// and is not stored in source control.
	mockRepository := ports.NewMockRedirectRepository(controller)

	// Create the service based on the mocked repository
	// Stub the mock service into the bookController
	mockService := redirectservice.NewService(mockRepository)
	redirectHandler := HttpHandler{mockService}

	// Create the routes
	router := mux.NewRouter()
	router.HandleFunc("/redirect", redirectHandler.Create).Methods("POST")

	// Subtest 1: Create a redirect with a valid body
	t.Run("Valid_RequestObject", func(t *testing.T) {
		// Todo: Implement the test

	})

	// Subtest 2: Create a redirect with an invalid body
	t.Run("Invalid_RequestObject", func(t *testing.T) {
		// Todo: Implement the test

	})

	// Subtest 3: Create a redirect with no body
	t.Run("No_RequestObject", func(t *testing.T) {
		// Todo: Implement the test

	})

}
